---
title: "Desktop Application & Vue Frontend Updates: GSoC 2025 Final Report"
date: 2025-08-31T14:04:00+05:30
author: Harsh Rao
type: post
---

![gsoc-cover](/images/Harsh_Rao/Final_report.jpg)

**Hey Everyone 😊**,

Welcome to my final blog for Google Summer of Code 2025 for the project **Desktop Application & Vue Frontend Updates**

### What is the Project about🖥
---

> **[_Desktop Application & Vue Frontend Updates:_](https://summerofcode.withgoogle.com/programs/2025/projects/RLcXZOiF)
> The project works on the Vue Simulator and aims at pushing the vue-simulator to production. We have achieved several milestones like Authentication model, a beautiful Release Pipeline for Tauri simulator, version sync for v0 and v1, a brand new Testbench UI and many more. Let's dive into them right away !!**

## Major statures that have been added and merged include:
- Authentication model for Web and Tauri Simulator
- Release Pipeline for Tauri Simulator
- An improved Testbench UI/UX
- Vue-Simulator integration with the primary codebase
- Legacy feature sync to v0 and v1
- Pushing vue simulator to Production
- Tackling major bugs

---

[<h3>Project link</h3>](https://github.com/orgs/CircuitVerse/projects/43/views/2) 

---
# Authentication Model for Web and Tauri Simulator
Let's begin with the very own Authentication model for vue-simulator that we recently published. The reason we needed a seperate Authentication model for vue simulator is because of Tauri. Earlier we were simply changing the `path` in the `URL` to direct to the Login page of Circuitverse for Authentication. This particulat method fails for the Tauri simulator because:<br> 
- It is a stand alone simulator with no connection to the primary codebase.
- We want the Tauri simulator to also work when user is offline.
- We cannot redirect links like we do in web in Tauri.<br>

To answer those needs, it was the need of the hour to create an authentication model for the vue-simulator and so did we deliver.The authentication system in the CircuitVerse frontend is built using **Vue 3 with TypeScript**.  
It handles both **login** and **signup** flows via API requests to the CircuitVerse backend.

- **Frontend Tech**: Vue 3 + TypeScript + Pinia (Auth Store)  
- **API Layer**: Fetch (with [Tauri HTTP plugin](https://tauri.app))  
- **Backend Endpoints**:  
  - `POST /api/v1/auth/login`  
  - `POST /api/v1/auth/signup`  

## Authentication Flow

1. **Auth Modal Handling**
   - A modal component (`authModal`) is used to toggle between **login** and **signup**.
   - Users can switch modes dynamically without leaving the page.

2. **Form Validation**
   - Basic client-side validation rules:  
     - Required fields must not be empty.  
     - Valid email format (`/.+@.+\..+/`).  
     - Password must be at least 6 characters.  

3. **Request Building**
   - Depending on mode (`isLoginMode`), the request body changes:
     - **Login**: `{ email, password }`  
     - **Signup**: `{ name, email, password }`
   - Requests are sent as JSON with appropriate headers.

4. **API Communication**
   - Uses the `fetch` function (via Tauri plugin when inside desktop app).
   - On success, the backend responds with an **auth token**.

5. **State Management**
   - The received token is stored in the **Auth Store** (`useAuthStore()`).
   - Store handles:
     - Saving token
     - Fetching user ID
     - Sign-out / token removal

6. **Error Handling**
   - Common error responses:
     - `401 Unauthorized` → Invalid credentials  
     - `404 Not Found` → User does not exist  
     - `409 Conflict` → User already exists  
     - `422 Unprocessable Entity` → Invalid input  
   - Errors are shown to the user via a **snackbar** notification system.

These are some of the snaps of the Authentication model -<br>

![Authentication sample image 1](/images/Harsh_Rao/Authentication1.png)<br>
![Authentication sample image 2](/images/Harsh_Rao/Authentication2-final.png)
![Authentication sample image 3](/images/Harsh_Rao/Authentication3-final.png)<br>

# Automating Cross-Platform Desktop Releases
One of the key deliverables for my GSoC project was a reliable release pipeline for the CircuitVerse desktop app. I initially explored fully automated tools like semantic-release and release-it!, but they offered less manual control than we needed. The ideal solution needed to balance powerful automation with maintainer oversight.

The breakthrough was using GitHub Actions' workflow_dispatch. This allows us to trigger the release manually, providing input on the version type (major, minor, or patch), giving us the perfect blend of automation and control. This approach culminated in the final workflow that now powers our desktop releases.

## The Release Workflow Code
The entire process is encapsulated in a single GitHub Actions workflow file. It's composed of two primary jobs: build-tauri to compile the application across all platforms, and create-release to package and publish the final release.

```bash
name: Manually Triggered Desktop Release

permissions:
  contents: write
  actions: read

concurrency:
  group: desktop-release-${{ github.ref }}
  cancel-in-progress: true

on:
  workflow_dispatch:
    inputs:
      version-bump:
        description: 'The type of version bump (major, minor, or patch)'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major

jobs:
  build-tauri:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Cache Node.js Dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: ${{ runner.os }}-node-

      - name: Install Dependencies
        run: npm install
        shell: bash

      - name: Run Cross-Platform Build Script
        run: node build-desktop.js
        shell: bash

      - name: Setup Rust (stable)
        uses: dtolnay/rust-toolchain@stable

      - name: Install Linux Dependencies (Ubuntu)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt update
          sudo apt install libwebkit2gtk-4.1-dev \
          build-essential \
          curl \
          wget \
          file \
          libxdo-dev \
          libssl-dev \
          libayatana-appindicator3-dev \
          librsvg2-dev
        shell: bash

      - name: Install macOS Dependencies
        if: matrix.os == 'macos-latest'
        run: |
          brew update
          brew install pkg-config
        shell: bash

      - name: Install Windows Dependencies
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          choco install -y wixtoolset nsis microsoft-edge-webview2-runtime

      - name: Cache Rust Dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: "./src-tauri"

      - name: Build Tauri App
        run: npm run tauri build
        shell: bash

      - name: Upload Tauri Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: Tauri Build Artifacts (${{ matrix.os }})
          path: |
            src-tauri/target/release/bundle

  create-release:
    runs-on: ubuntu-latest
    needs: build-tauri
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate Changelog
        id: changelog
        uses: TriPSs/conventional-changelog-action@v3
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare Release Assets
        run: |
          mkdir -p release-assets
          # Move all built files (.deb, .AppImage, .msi, .dmg) into one folder
          # The '|| true' prevents the workflow from failing if a specific file type doesn't exist
          find artifacts -type f \( -name "*.deb" -o -name "*.AppImage" -o -name "*.msi" -o -name "*.dmg" \) -exec cp {} release-assets/ \; || true
          
          if [ -d "artifacts/Tauri Build Artifacts (macos-latest)/src-tauri/target/release/bundle/macos" ]; then
            cd "artifacts/Tauri Build Artifacts (macos-latest)/src-tauri/target/release/bundle/macos"
            for app in *.app; do
              zip -r "../../../release-assets/${app%.app}.zip" "$app"
            done
            cd -
          fi
          
          echo "Prepared release assets:"
          ls -l release-assets/

      - name: Install GitHub CLI
        run: |
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y

      - name: Determine New Version and Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Fetch the latest tag from the repository
          LATEST_TAG=$(git tag --sort=-v:refname | head -n 1)
          if [[ -z "$LATEST_TAG" ]]; then
            # If no tags exist, start from v0.0.0
            LATEST_TAG="v0.0.0"
          fi
          
          # Parse the latest tag to get major, minor, and patch numbers
          if [[ "$LATEST_TAG" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            MAJOR=${BASH_REMATCH[1]}
            MINOR=${BASH_REMATCH[2]}
            PATCH=${BASH_REMATCH[3]}
          else
            echo "Could not parse latest tag: $LATEST_TAG. Starting from v0.1.0."
            MAJOR=0; MINOR=1; PATCH=0
          fi
          # Increment the version based on the manual input
          BUMP_TYPE="${{ github.event.inputs.version-bump }}"
          if [ "$BUMP_TYPE" == "major" ]; then
            MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0
          elif [ "$BUMP_TYPE" == "minor" ]; then
            MINOR=$((MINOR + 1)); PATCH=0
          else # Default to patch
            PATCH=$((PATCH + 1))
          fi
          
          if [ -n "${{ steps.changelog.outputs.tag }}" ]; then
            NEW_VERSION="${{ steps.changelog.outputs.tag }}"
            echo "Using tag from changelog output: $NEW_VERSION"
          else
            NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
          fi
          echo "Creating new release: $NEW_VERSION"
          
          # Get the release notes generated by the changelog action
          CHANGELOG_NOTES_FILE="RELEASE_NOTES.md"
          printf "%s\n" "${{ steps.changelog.outputs.changelog }}" > "$CHANGELOG_NOTES_FILE"
          
          # Create the GitHub Release and upload all assets
          test -n "$(ls -A release-assets 2>/dev/null)" || { echo "No assets to upload"; exit 1; }
          gh release create "$NEW_VERSION" \
            --title "CircuitVerse Desktop $NEW_VERSION" \
            --notes-file "$CHANGELOG_NOTES_FILE" \
            release-assets/*
```
**Precursor:** We have also added `conventional-commit` to the workflows, this ensures smoothness in the Automation for version tag generation. This also helps give the maintainers a good holistic view of where the simulator stands at, in-turn helping them choose the `minor`,`patch` or `major` version bump in the Release. ([PR #656](https://github.com/CircuitVerse/cv-frontend-vue/pull/656))<br>
From here on the commits made by everyone would be needing to follow the [conventional-commits](https://www.conventionalcommits.org/en/v1.0.0/), Some of them are as follows:
#### Types

The **type** indicates the nature of the change:

- **feat**: A new feature
- **fix**: A bug fix
- **docs**: Documentation changes
- **style**: Code style/formatting changes (no logic change)
- **refactor**: Code changes that neither fix a bug nor add a feature
- **perf**: Performance improvements
- **test**: Adding or updating tests
- **chore**: Build process, tooling, or maintenance tasks
- **ci**: CI/CD related changes


## How It Works 🧐<br>
The workflow operates in two sequential jobs:<br>
**Job 1: `build-tauri`**
This job is the workhorse, responsible for compiling the application. It uses a matrix strategy to run three parallel jobs, one for each target OS: `ubuntu-latest`, `windows-latest`, and `macos-latest`. This is the key to efficient cross-platform building.

- **Environment Setup:** Each job begins by checking out the code and setting up the required toolchains, like Node.js and Rust. Crucially, it also installs OS-specific dependencies needed for compilation, such as `libwebkit2gtk-4.1-dev` on Ubuntu or `wixtoolset` on Windows.

- **Dependency Caching:** To dramatically speed up build times on subsequent runs, the workflow caches both the Node.js (`.npm`) and Rust (`.cargo`, `target`) dependency directories. This avoids re-downloading and re-compiling hundreds of packages every time.

- **Build & Upload:** The job then runs the tauri build command, which creates the native application installers. Once complete, it uses the `actions/upload-artifact` action to save these installers, making them available to the next job in the workflow.

**Job 2: `create-release`**
This job only runs after all three build jobs have completed successfully (needs: build-tauri). It handles the final packaging and publishing.

- **Artifact & Code Aggregation:** It begins by downloading all the build artifacts (the installers for Linux, macOS, and Windows) from the previous job. It also checks out the repository with `fetch-depth: 0` to ensure it has the full git history, which is essential for the next step.

- **Automated Changelog:** The `conventional-changelog-action` scans the git history since the last release tag. Based on conventional commit messages (like `feat:`, `fix:`, etc.), it automatically generates professional, well-formatted release notes.

- **Versioning:** A bash script then determines the new version number. It fetches the latest git tag (e.g., `v1.2.3`), parses it, and increments the version based on the version-bump input (`patch`, `minor`, or `major`) that was provided when the workflow was triggered.

- **Publishing:** Finally, using the GitHub CLI, the script creates a new GitHub Release. It tags the commit with the new version, sets the release title, attaches the auto-generated changelog as the release notes, and uploads all the cross-platform installers as release assets.

**The Final Product ([PR #636](https://github.com/CircuitVerse/cv-frontend-vue/pull/636))✨**
The result is a beautifully simple and powerful release process. Now, any maintainer can go to the repository's "`Actions`" tab, select the "`Manually Triggered Desktop Release`" workflow, choose whether it's a `major`, `minor`, or `patch` release, and click "Run workflow."

![Release Pipelines sample image 2](/images/Harsh_Rao/Release_Pipeline_1.png)

From there, everything is automated. Within minutes, a new, cross-platform release is published to GitHub, complete with installers for every OS and a professional changelog, ready for our users. This pipeline removes manual effort, eliminates human error, and ensures our releases are consistent and reliable every single time.

![Release Pipelines sample image 2](/images/Harsh_Rao/Release_Pipeline_2.png)

~~**[GIF/Video Here]: A short screen recording showing the process from clicking "Run workflow" to the final, published release on the GitHub Releases page.**~~
{{< video src="/videos/Harsh_Rao/release-pipeline-final.mp4" controls=true preload=true >}}

# The Artistic new Testbench UI

This has been the artistic side of the project. We have had the Testbench UI for a while now, upto now it had recieved 2 major UI revamps during some of the previous GSOC projects. This time we went outside the current colour palette. We have used the classic Circuitverse green with white, which gives it a soft and user-friendly look.

Here are some snapshots of the new Testbench UI


![Testbench sample image 1](/images/Harsh_Rao/Testbench_1.png)
![Testbench sample image 2](/images/Harsh_Rao/Testbench_2.png)

Here is a video showcasing the working of the new Testbench

{{< video src="/videos/Harsh_Rao/Testbench.mp4" controls=true preload=true >}}

# Legacy version sync to versions v0 and v1

After the previous year's GSOC project on implementing version control, we needed to sync the legacy simulator versions to the versioned folders while syncing the changes in the src folder to v0 and v1 too. This was carried out in 3 steps.<br>
**Step 1:** This step was brute-force copying all of the files from the `src` folder to the versioned directiories `v0` and `v1`.
**Step 2:** Then we compared all of the changes that existed in `src` and not in `v0` and `v1`. We came across many small features that were missing for `src` which needed to be re-written, for eg: the version mismatch dialogue for the vue simulator in `openOffline.vue`. ([PR #599](https://github.com/CircuitVerse/cv-frontend-vue/pull/599))
**Step 3:** This was the part where we tested the result of the change, since the change built up a massive PR, this step took time and also proved beneficial. We came across a few shortcomings, the major one being the preview circuits for version `v1` going into infinite reload. This was created due to an error that ocurred during the feature sync to `v1` folder, ([PR #647](https://github.com/CircuitVerse/cv-frontend-vue/pull/647)) 

# Pushing vue-simulator to Production

---

### Pull Requests
- PR : [Authentication Model](https://github.com/CircuitVerse/cv-frontend-vue/pull/657)
- PR : [Release Pipelines](https://github.com/CircuitVerse/cv-frontend-vue/pull/636)
- PR : [Testbench UI/UX](https://github.com/CircuitVerse/cv-frontend-vue/pull/650)
- PR : [Versioning PR](https://github.com/CircuitVerse/cv-frontend-vue/pull/599)
- PR : [Conventional commit workflow](https://github.com/CircuitVerse/cv-frontend-vue/pull/656)
- PR : [Version sync](https://github.com/CircuitVerse/cv-frontend-vue/pull/599)
- PR : [Infinite loop](https://github.com/CircuitVerse/cv-frontend-vue/pull/647)

---
## Learning
I learned a lot related to working of things in software. Most of all I learned how to look for solutions. I really liked the part where I sat plannig with my mentors as to how we are gonna be approaching different contingencies. We implemented many ideas and had to leave behind many too. I learned about github actions, Vuejs, Rust and ts a lot. Also got to try my hands on Rails and Ruby too. 

These few weeks taught me a lot about how the industry works and how work is done. I learned a lot of things outside coding and got to meet many crazy people and learn from them.


## Conclusion

My journey so far has been nothing but a roller-coaster. Each week I stumbled upon things I didn't know, then learned it, bugged my mentor about it, experimented with it and then implemented it. It has truly been a developer's dream till now. My mentors and CircuitVerse community have been very helpful and inspirational in my little journey. Looking forward to contribute and learn more.

I would like especially thank my mentor [Aryann Dwivedi](https://github.com/aryanndwi123) for being an amazing mentor and guiding my way out of the walls I kept head-butting into, I would also like to thank  [Niladri Adhikary](https://github.com/niladrix719), [Arnab Das](https://github.com/Arnabdaz), [Aboobacker MK](https://github.com/tachyons), [Vedant Jain](https://github.com/vedant-jain03) and other mentors and circuitverse contributors for helping and mentoring me throught the journey.

